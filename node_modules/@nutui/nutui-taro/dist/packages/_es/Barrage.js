/*!
* @nutui/nutui-taro v3.1.15 Fri Jan 21 2022 15:42:05 GMT+0800 (GMT+08:00)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import { ref, computed, onMounted, onUnmounted, onDeactivated, watch, reactive, openBlock, createElementBlock, normalizeClass, createElementVNode, Fragment, renderList, normalizeStyle, toDisplayString } from "vue";
import { c as createComponent } from "./component.js";
import Taro from "@tarojs/taro";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
const { componentName, create } = createComponent("barrage");
const _sfc_main = create({
  props: {
    danmu: {
      type: Array,
      default: () => []
    },
    frequency: {
      type: Number,
      default: 200
    },
    speeds: {
      type: Number,
      default: 2e3
    },
    rows: {
      type: Number,
      default: 3
    },
    top: {
      type: Number,
      default: 10
    },
    loop: {
      type: Boolean,
      default: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const timeId = ref(new Date().getTime());
    const danmuList = ref(props.danmu);
    const rows = ref(props.rows);
    const top = ref(props.top);
    const speeds = props.speeds;
    const classes = computed(() => {
      const prefixCls = componentName;
      return {
        [prefixCls]: true,
        ["dmBody" + timeId.value]: true
      };
    });
    onMounted(() => {
      runStep();
    });
    onUnmounted(() => {
      danmuList.value = [];
    });
    onDeactivated(() => {
      danmuList.value = [];
    });
    watch(() => props.danmu, (newValue, oldVlaue) => {
      danmuList.value = [...newValue];
    });
    const add = (word) => {
      danmuList.value = [...danmuList.value, word];
      runStep();
    };
    const getNode = (index) => {
      const query = Taro.createSelectorQuery();
      setTimeout(() => {
        let width = 100;
        query.select(".dmBody" + timeId.value).boundingClientRect((rec) => {
          width = rec.width || 300;
        });
        query.select(".dmitem" + index).boundingClientRect((recs) => {
          let height = recs.height;
          let nodeTop = index % rows.value * (height + top.value) + 20 + "px";
          styleInfo(index, nodeTop, width);
        }).exec();
      }, 500);
    };
    const runStep = () => {
      danmuList.value.forEach((item, index) => {
        getNode(index);
      });
    };
    let styleList = reactive([]);
    const styleInfo = (index, nodeTop, width) => {
      let timeIndex = index - rows.value > 0 ? index - rows.value : 0;
      let list = styleList;
      let time = list[timeIndex] ? Number(list[timeIndex]["--time"]) : 0;
      let obj = {
        top: nodeTop,
        "--time": `${props.frequency * index + time}`,
        animationDuration: `${speeds}ms`,
        animationIterationCount: `${props.loop ? "infinite" : 1}`,
        animationDelay: `${props.frequency * index + time}ms`,
        "--move-distance": `-${width}px`
      };
      styleList.push(obj);
    };
    return { classes, danmuList, add, styleList };
  }
});
const _hoisted_1 = {
  class: "dmContainer",
  id: "dmContainer"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["dmBody", _ctx.classes])
  }, [
    createElementVNode("view", _hoisted_1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.danmuList, (item, index) => {
        return openBlock(), createElementBlock("view", {
          key: "danmu" + index,
          class: normalizeClass(["dmitem", "dmitem" + index, "move"]),
          style: normalizeStyle(_ctx.styleList[index])
        }, toDisplayString(item.length > 8 ? item.substr(0, 8) + "..." : item), 7);
      }), 128))
    ])
  ], 2);
}
var index_taro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index_taro as default };
