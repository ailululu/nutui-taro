var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
/*!
* @nutui/nutui-taro v3.1.15 Fri Jan 21 2022 15:42:05 GMT+0800 (GMT+08:00)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import Taro from "@tarojs/taro";
import { u as useTouch } from "./index.js";
import { computed, ref, onMounted, reactive, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, renderSlot } from "vue";
import { c as createComponent } from "./component.js";
import { u as useTaroRect } from "./index2.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
const { componentName, create } = createComponent("swipe");
const _sfc_main = create({
  props: {
    name: {
      type: String,
      default: ""
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: false
    },
    touchMovePreventDefault: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["open", "close"],
  setup(props, { emit }) {
    const refRandomId = Math.random().toString(36).slice(-8);
    const classes = computed(() => {
      const prefixCls = componentName;
      return {
        [prefixCls]: true
      };
    });
    const getRefWidth = async (ref2) => {
      let rect = await useTaroRect(ref2, Taro);
      return rect.width || 0;
    };
    const leftRef = ref();
    const leftRefWidth = ref(0);
    const rightRef = ref();
    const rightRefWidth = ref(0);
    const initWidth = async () => {
      leftRefWidth.value = await getRefWidth(leftRef);
      rightRefWidth.value = await getRefWidth(rightRef);
    };
    onMounted(() => {
      setTimeout(() => {
        initWidth();
      }, 100);
    });
    let opened = false;
    let position = "";
    let oldPosition = "";
    const state = reactive({
      offset: 0,
      moving: false
    });
    const open = (p = "") => {
      opened = true;
      if (p) {
        state.offset = p === "left" ? -rightRefWidth.value : leftRefWidth.value;
      }
      emit("open", {
        name: props.name,
        position: position || p
      });
    };
    const close = () => {
      state.offset = 0;
      opened = false;
      emit("close", {
        name: props.name,
        position
      });
    };
    const touchStyle = computed(() => {
      return {
        transform: `translate3d(${state.offset}px, 0, 0)`
      };
    });
    const setoffset = (deltaX) => {
      position = deltaX > 0 ? "right" : "left";
      let offset = deltaX;
      switch (position) {
        case "left":
          if (opened && oldPosition === position) {
            offset = -rightRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > rightRefWidth.value ? -rightRefWidth.value : deltaX;
          }
          break;
        case "right":
          if (opened && oldPosition === position) {
            offset = leftRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > leftRefWidth.value ? leftRefWidth.value : deltaX;
          }
          break;
      }
      state.offset = offset;
    };
    const touch = useTouch();
    const touchMethods = {
      onTouchStart(event) {
        if (props.disabled)
          return;
        touch.start(event);
      },
      async onTouchMove(event) {
        if (props.disabled)
          return;
        touch.move(event);
        if (touch.isHorizontal()) {
          state.moving = true;
          setoffset(touch.deltaX.value);
          if (props.touchMovePreventDefault) {
            event.preventDefault();
          }
          if (props.touchMoveStopPropagation) {
            event.stopPropagation();
          }
        }
      },
      onTouchEnd() {
        if (state.moving) {
          state.moving = false;
          oldPosition = position;
          switch (position) {
            case "left":
              if (Math.abs(state.offset) <= rightRefWidth.value / 2) {
                close();
              } else {
                state.offset = -rightRefWidth.value;
                open();
              }
              break;
            case "right":
              if (Math.abs(state.offset) <= leftRefWidth.value / 2) {
                close();
              } else {
                state.offset = leftRefWidth.value;
                open();
              }
              break;
          }
        }
      }
    };
    return __spreadProps(__spreadValues({
      classes,
      touchStyle
    }, touchMethods), {
      leftRef,
      rightRef,
      refRandomId,
      open,
      close
    });
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = { class: "nut-swipe__content" };
const _hoisted_3 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.touchStyle),
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
    onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createElementVNode("view", {
      class: "nut-swipe__left",
      ref: "leftRef",
      id: "leftRef-" + _ctx.refRandomId
    }, [
      renderSlot(_ctx.$slots, "left")
    ], 8, _hoisted_1),
    createElementVNode("view", _hoisted_2, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createElementVNode("view", {
      class: "nut-swipe__right",
      ref: "rightRef",
      id: "rightRef-" + _ctx.refRandomId
    }, [
      renderSlot(_ctx.$slots, "right")
    ], 8, _hoisted_3)
  ], 38);
}
var index_taro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index_taro as default };
