/*!
* @nutui/nutui-taro v3.1.15 Fri Jan 21 2022 15:42:05 GMT+0800 (GMT+08:00)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import Taro from "@tarojs/taro";
import { ref, reactive, watch, onMounted, computed, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, renderSlot, createTextVNode, toDisplayString } from "vue";
import { c as createComponent } from "./component.js";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
const { componentName, create } = createComponent("circleprogress");
const _sfc_main = create({
  props: {
    progress: {
      type: [Number, String],
      required: true
    },
    strokeInnerWidth: {
      type: [Number, String],
      default: 10
    },
    isAuto: {
      tyep: Boolean,
      default: false
    },
    progressOption: {
      type: Object,
      default: () => {
      }
    }
  },
  setup(props, { emit }) {
    const rotateLeft = ref();
    const rotateRight = ref();
    const InnerWidth = ref(props.strokeInnerWidth);
    const isMobile = ref(false);
    const cricleData = reactive({
      radius: 50,
      strokeOutWidth: 10,
      backColor: "#d9d9d9",
      progressColor: "red"
    });
    const loadPercent = (x, y) => {
      let rotate = x / y * 360;
      let rotateRc = 0;
      let rotateLc = 0;
      if (rotate < 180) {
        rotateRc = rotate + -45;
      } else {
        rotateRc = 135;
        rotateLc = rotate - 180 - 45;
        rotateLeft.value = rotateLc;
      }
      rotateRight.value = rotateRc;
    };
    watch(() => props.progress, (value) => {
      loadPercent(value, 100);
    });
    onMounted(() => {
      if (Taro.getEnv() === "WEB") {
        isMobile.value = true;
      } else {
        isMobile.value = false;
        loadPercent(props.progress, 100);
        Object.assign(cricleData, props.progressOption);
      }
    });
    const classes = computed(() => {
      const prefixCls = componentName;
      return {
        [prefixCls]: true
      };
    });
    const pieStyle = computed(() => {
      return {
        width: (cricleData.radius + cricleData.strokeOutWidth) * 2 + "px",
        height: (cricleData.radius + cricleData.strokeOutWidth) * 2 + "px"
      };
    });
    const mobileStyle = computed(() => {
      return {
        width: "100%",
        height: "100%"
      };
    });
    const RightStyle = computed(() => {
      return {
        transform: `rotate(${rotateRight.value + "deg"})`,
        transition: `all 0.3s`,
        borderTop: `${InnerWidth.value + "px"} solid ${cricleData.backColor};`,
        borderLeft: `${InnerWidth.value + "px"} solid  ${cricleData.backColor};`,
        borderBottom: `${InnerWidth.value + "px"} solid ${cricleData.progressColor};`,
        borderRight: `${InnerWidth.value + "px"} solid ${cricleData.progressColor};`
      };
    });
    const LeftStyle = computed(() => {
      return {
        transform: `rotate(${rotateLeft.value + "deg"})`,
        transition: `all 0.3s`,
        borderTop: `${InnerWidth.value + "px"} solid ${cricleData.backColor};`,
        borderLeft: `${InnerWidth.value + "px"} solid  ${cricleData.backColor};`,
        borderBottom: `${InnerWidth.value + "px"} solid ${cricleData.progressColor};`,
        borderRight: `${InnerWidth.value + "px"} solid ${cricleData.progressColor};`
      };
    });
    const option = computed(() => {
      let baseOption = {
        radius: 50,
        strokeOutWidth: 10,
        backColor: "#d9d9d9",
        progressColor: "red",
        cy: 1,
        cx: 1,
        size: 1,
        startPosition: ""
      };
      Object.assign(baseOption, props.progressOption);
      baseOption.cy = baseOption.cx = baseOption.radius + baseOption.strokeOutWidth;
      baseOption.size = (baseOption.radius + baseOption.strokeOutWidth) * 2;
      baseOption.startPosition = "rotate(-90," + baseOption.cx + "," + baseOption.cy + ")";
      return baseOption;
    });
    const arcLength = computed(() => {
      let circleLength = Math.floor(2 * Math.PI * option.value.radius);
      let progressLength = props.progress / 100 * circleLength;
      return `${progressLength},${circleLength}`;
    });
    return {
      isMobile,
      rotateLeft,
      InnerWidth,
      rotateRight,
      classes,
      pieStyle,
      RightStyle,
      LeftStyle,
      option,
      arcLength,
      mobileStyle
    };
  }
});
const _hoisted_1 = { class: "nut-circleprogress__right" };
const _hoisted_2 = { class: "nut-circleprogress__line nut-circleprogress__r" };
const _hoisted_3 = { class: "nut-circleprogress__progress" };
const _hoisted_4 = { class: "nut-circleprogress__left" };
const _hoisted_5 = { class: "nut-circleprogress__line nut-circleprogress__l" };
const _hoisted_6 = { key: 1 };
const _hoisted_7 = ["height", "width"];
const _hoisted_8 = ["r", "cx", "cy", "stroke", "stroke-width"];
const _hoisted_9 = ["r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-width", "transform"];
const _hoisted_10 = { class: "nut-circleprogress__progress" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.pieStyle)
  }, [
    !_ctx.isMobile ? (openBlock(), createElementBlock("div", {
      key: 0,
      style: normalizeStyle(_ctx.mobileStyle)
    }, [
      createElementVNode("div", _hoisted_1, [
        createElementVNode("div", _hoisted_2, [
          createElementVNode("div", {
            class: "nut-circleprogress__line__c",
            style: normalizeStyle(_ctx.RightStyle)
          }, null, 4)
        ])
      ]),
      createElementVNode("div", _hoisted_3, [
        !_ctx.isAuto ? renderSlot(_ctx.$slots, "default", { key: 0 }, () => [
          createTextVNode(toDisplayString(_ctx.progress) + "%", 1)
        ]) : renderSlot(_ctx.$slots, "default", { key: 1 })
      ]),
      createElementVNode("div", _hoisted_4, [
        createElementVNode("div", _hoisted_5, [
          createElementVNode("div", {
            class: "nut-circleprogress__line__c",
            style: normalizeStyle(_ctx.LeftStyle)
          }, null, 4)
        ])
      ])
    ], 4)) : (openBlock(), createElementBlock("div", _hoisted_6, [
      (openBlock(), createElementBlock("svg", {
        height: _ctx.option.size,
        width: _ctx.option.size,
        "x-mlns": "http://www.w3.org/200/svg"
      }, [
        createElementVNode("circle", {
          r: _ctx.option.radius,
          cx: _ctx.option.cx,
          cy: _ctx.option.cy,
          stroke: _ctx.option.backColor,
          "stroke-width": _ctx.option.strokeOutWidth,
          fill: "none"
        }, null, 8, _hoisted_8),
        createElementVNode("circle", {
          r: _ctx.option.radius,
          cx: _ctx.option.cx,
          cy: _ctx.option.cy,
          stroke: _ctx.option.progressColor,
          "stroke-dasharray": _ctx.arcLength,
          "stroke-width": _ctx.strokeInnerWidth,
          fill: "none",
          transform: _ctx.option.startPosition,
          "stroke-linecap": "round",
          style: { "transition": "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease 0s" }
        }, null, 8, _hoisted_9)
      ], 8, _hoisted_7)),
      createElementVNode("div", _hoisted_10, [
        !_ctx.isAuto ? renderSlot(_ctx.$slots, "default", { key: 0 }, () => [
          createTextVNode(toDisplayString(_ctx.progress) + "%", 1)
        ]) : renderSlot(_ctx.$slots, "default", { key: 1 })
      ])
    ]))
  ], 6);
}
var index_taro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index_taro as default };
