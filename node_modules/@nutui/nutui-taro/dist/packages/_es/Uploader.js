var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
/*!
* @nutui/nutui-taro v3.1.15 Fri Jan 21 2022 15:42:05 GMT+0800 (GMT+08:00)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import { reactive, computed, resolveComponent, openBlock, createElementBlock, normalizeClass, renderSlot, createBlock, createCommentVNode, Fragment, renderList, createElementVNode, toDisplayString, createVNode, createTextVNode } from "vue";
import { c as createComponent } from "./component.js";
import Taro from "@tarojs/taro";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
class UploadOptions {
  constructor() {
    __publicField(this, "url", "");
    __publicField(this, "name", "file");
    __publicField(this, "formData");
    __publicField(this, "method", "post");
    __publicField(this, "xhrState", 200);
    __publicField(this, "timeout", 30 * 1e3);
    __publicField(this, "headers", {});
    __publicField(this, "withCredentials", false);
    __publicField(this, "onStart");
    __publicField(this, "taroFilePath");
    __publicField(this, "onProgress");
    __publicField(this, "onSuccess");
    __publicField(this, "onFailure");
  }
}
class Uploader {
  constructor(options) {
    __publicField(this, "options");
    this.options = options;
  }
  upload() {
    var _a;
    const options = this.options;
    const xhr = new XMLHttpRequest();
    xhr.timeout = options.timeout;
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (e) => {
        var _a2;
        (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, e, options);
      }, false);
      xhr.onreadystatechange = () => {
        var _a2, _b;
        if (xhr.readyState === 4) {
          if (xhr.status == options.xhrState) {
            (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, xhr.responseText, options);
          } else {
            (_b = options.onFailure) == null ? void 0 : _b.call(options, xhr.responseText, options);
          }
        }
      };
      xhr.withCredentials = options.withCredentials;
      xhr.open(options.method, options.url, true);
      for (const [key, value] of Object.entries(options.headers)) {
        xhr.setRequestHeader(key, value);
      }
      (_a = options.onStart) == null ? void 0 : _a.call(options, options);
      xhr.send(options.formData);
    } else {
      console.warn("\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 XMLHttpRequest");
    }
  }
  uploadTaro(uploadFile) {
    var _a;
    const options = this.options;
    const uploadTask = uploadFile({
      url: options.url,
      filePath: options.taroFilePath,
      header: __spreadValues({
        "Content-Type": "multipart/form-data"
      }, options.headers),
      formData: options.formData,
      name: options.name,
      success(response) {
        var _a2, _b;
        if (options.xhrState == response.statusCode) {
          (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, response, options);
        } else {
          (_b = options.onFailure) == null ? void 0 : _b.call(options, response, options);
        }
      },
      fail(e) {
        var _a2;
        (_a2 = options.onFailure) == null ? void 0 : _a2.call(options, e, options);
      }
    });
    (_a = options.onStart) == null ? void 0 : _a.call(options, options);
    uploadTask.progress((res) => {
      var _a2;
      (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, res, options);
    });
  }
}
const { componentName, create } = createComponent("uploader");
class FileItem {
  constructor() {
    __publicField(this, "status", "ready");
    __publicField(this, "message", "\u51C6\u5907\u5B8C\u6210");
    __publicField(this, "uid", new Date().getTime().toString());
    __publicField(this, "url");
    __publicField(this, "path");
    __publicField(this, "name");
    __publicField(this, "type");
    __publicField(this, "percentage", 0);
    __publicField(this, "formData", {});
  }
}
const _sfc_main = create({
  props: {
    name: { type: String, default: "file" },
    url: { type: String, default: "" },
    sizeType: {
      type: Array,
      default: () => ["original", "compressed"]
    },
    sourceType: {
      type: Array,
      default: () => ["album", "camera"]
    },
    timeout: { type: [Number, String], default: 1e3 * 30 },
    fileList: { type: Array, default: () => [] },
    isPreview: { type: Boolean, default: true },
    listType: { type: String, default: "picture" },
    isDeletable: { type: Boolean, default: true },
    method: { type: String, default: "post" },
    capture: { type: Boolean, default: false },
    maximize: { type: [Number, String], default: Number.MAX_VALUE },
    maximum: { type: [Number, String], default: 9 },
    clearInput: { type: Boolean, default: true },
    accept: { type: String, default: "*" },
    headers: { type: Object, default: {} },
    data: { type: Object, default: {} },
    uploadIcon: { type: String, default: "photograph" },
    uploadIconSize: { type: [String, Number], default: "" },
    xhrState: { type: [Number, String], default: 200 },
    disabled: { type: Boolean, default: false },
    autoUpload: { type: Boolean, default: true },
    beforeUpload: {
      type: Function,
      default: null
    },
    beforeDelete: {
      type: Function,
      default: (file, files) => {
        return true;
      }
    },
    onChange: { type: Function }
  },
  emits: [
    "start",
    "progress",
    "oversize",
    "success",
    "failure",
    "change",
    "delete",
    "update:fileList",
    "file-item-click"
  ],
  setup(props, { emit }) {
    const fileList = reactive(props.fileList);
    let uploadQueue = [];
    const classes = computed(() => {
      const prefixCls = componentName;
      return {
        [prefixCls]: true
      };
    });
    const chooseImage = () => {
      if (props.disabled) {
        return;
      }
      Taro.chooseImage({
        count: props.maximum * 1 - props.fileList.length,
        sizeType: props.sizeType,
        sourceType: props.sourceType,
        success: onChange
      });
    };
    const fileItemClick = (fileItem) => {
      emit("file-item-click", { fileItem });
    };
    const executeUpload = (fileItem, index) => {
      const uploadOption = new UploadOptions();
      uploadOption.name = props.name;
      uploadOption.url = props.url;
      for (const [key, value] of Object.entries(props.data)) {
        fileItem.formData[key] = value;
      }
      uploadOption.formData = fileItem.formData;
      uploadOption.method = props.method;
      uploadOption.headers = props.headers;
      uploadOption.taroFilePath = fileItem.path;
      uploadOption.onStart = (option) => {
        fileItem.status = "ready";
        fileItem.message = "\u51C6\u5907\u4E0A\u4F20";
        clearUploadQueue(index);
        emit("start", option);
      };
      uploadOption.onProgress = (event, option) => {
        fileItem.status = "uploading";
        fileItem.message = "\u4E0A\u4F20\u4E2D";
        fileItem.percentage = event.progress;
        emit("progress", { event, option, percentage: fileItem.percentage });
      };
      uploadOption.onSuccess = (data, option) => {
        fileItem.status = "success";
        fileItem.message = "\u4E0A\u4F20\u6210\u529F";
        emit("success", {
          data,
          option,
          fileItem
        });
        emit("update:fileList", fileList);
      };
      uploadOption.onFailure = (data, option) => {
        fileItem.status = "error";
        fileItem.message = "\u4E0A\u4F20\u5931\u8D25";
        emit("failure", {
          data,
          option,
          fileItem
        });
      };
      let task = new Uploader(uploadOption);
      if (props.autoUpload) {
        task.uploadTaro(Taro.uploadFile);
      } else {
        uploadQueue.push(new Promise((resolve, reject) => {
          resolve(task);
        }));
      }
    };
    const clearUploadQueue = (index = -1) => {
      if (index > -1) {
        uploadQueue.splice(index, 1);
      } else {
        uploadQueue = [];
      }
    };
    const submit = () => {
      Promise.all(uploadQueue).then((res) => {
        res.forEach((i) => i.uploadTaro(Taro.uploadFile));
      });
    };
    const readFile = (files) => {
      const imgReg = /\.(png|jpeg|jpg|webp|gif)$/i;
      files.forEach((file, index) => {
        let fileType = file.type;
        const fileItem = reactive(new FileItem());
        if (!fileType && imgReg.test(file.path)) {
          fileType = "image";
        }
        fileItem.path = file.path;
        fileItem.name = file.path;
        fileItem.status = "ready";
        fileItem.message = "\u7B49\u5F85\u4E0A\u4F20";
        fileItem.type = fileType;
        if (props.isPreview) {
          fileItem.url = file.path;
        }
        fileList.push(fileItem);
        executeUpload(fileItem, index);
      });
    };
    const filterFiles = (files) => {
      const maximum = props.maximum * 1;
      const maximize = props.maximize * 1;
      const oversizes = new Array();
      files = files.filter((file) => {
        if (file.size > maximize) {
          oversizes.push(file);
          return false;
        } else {
          return true;
        }
      });
      if (oversizes.length) {
        emit("oversize", oversizes);
      }
      if (files.length > maximum) {
        files.splice(maximum - 1, files.length - maximum);
      }
      return files;
    };
    const onDelete = (file, index) => {
      clearUploadQueue(index);
      if (props.beforeDelete(file, fileList)) {
        fileList.splice(index, 1);
        emit("delete", {
          file,
          fileList
        });
      } else {
        console.log("\u7528\u6237\u963B\u6B62\u4E86\u5220\u9664\uFF01");
      }
    };
    const onChange = (res) => {
      const { tempFilePaths, tempFiles } = res;
      if (props.beforeUpload) {
        props.beforeUpload(tempFiles).then((f) => {
          const _files = filterFiles(f);
          readFile(_files);
        });
      } else {
        const _files = filterFiles(tempFiles);
        readFile(_files);
      }
      emit("change", {
        fileList
      });
    };
    return {
      onDelete,
      fileList,
      classes,
      chooseImage,
      fileItemClick,
      clearUploadQueue,
      submit
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "nut-uploader__slot"
};
const _hoisted_2 = {
  key: 0,
  class: "nut-uploader__preview-img"
};
const _hoisted_3 = {
  key: 0,
  class: "nut-uploader__preview__progress"
};
const _hoisted_4 = { class: "nut-uploader__preview__progress__msg" };
const _hoisted_5 = {
  key: 1,
  class: "nut-uploader__preview__progress"
};
const _hoisted_6 = { class: "nut-uploader__preview__progress__msg" };
const _hoisted_7 = ["onClick", "src"];
const _hoisted_8 = {
  key: 4,
  class: "nut-uploader__preview-img__file"
};
const _hoisted_9 = ["onClick"];
const _hoisted_10 = { class: "tips" };
const _hoisted_11 = {
  key: 1,
  class: "nut-uploader__preview-list"
};
const _hoisted_12 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_progress = resolveComponent("nut-progress");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_1, [
      renderSlot(_ctx.$slots, "default"),
      _ctx.maximum - _ctx.fileList.length ? (openBlock(), createBlock(_component_nut_button, {
        key: 0,
        class: "nut-uploader__input",
        onClick: _ctx.chooseImage
      }, null, 8, ["onClick"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.fileList, (item, index) => {
      var _a;
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(["nut-uploader__preview", [_ctx.listType]]),
        key: item.uid
      }, [
        _ctx.listType == "picture" && !_ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_2, [
          item.status == "ready" ? (openBlock(), createElementBlock("view", _hoisted_3, [
            createElementVNode("view", _hoisted_4, toDisplayString(item.message), 1)
          ])) : item.status != "success" ? (openBlock(), createElementBlock("view", _hoisted_5, [
            createVNode(_component_nut_icon, {
              color: "#fff",
              name: item.status == "error" ? "failure" : "loading"
            }, null, 8, ["name"]),
            createElementVNode("view", _hoisted_6, toDisplayString(item.message), 1)
          ])) : createCommentVNode("", true),
          _ctx.isDeletable ? (openBlock(), createBlock(_component_nut_icon, {
            key: 2,
            color: "rgba(0,0,0,0.6)",
            onClick: ($event) => _ctx.onDelete(item, index),
            class: "close",
            name: "failure"
          }, null, 8, ["onClick"])) : createCommentVNode("", true),
          ((_a = item.type) == null ? void 0 : _a.includes("image")) && item.url ? (openBlock(), createElementBlock("img", {
            key: 3,
            class: "nut-uploader__preview-img__c",
            onClick: ($event) => _ctx.fileItemClick(item),
            src: item.url
          }, null, 8, _hoisted_7)) : (openBlock(), createElementBlock("view", _hoisted_8, [
            createElementVNode("view", {
              class: "nut-uploader__preview-img__file__name",
              onClick: ($event) => _ctx.fileItemClick(item)
            }, [
              createVNode(_component_nut_icon, {
                color: "#808080",
                name: "link"
              }),
              createTextVNode("\xA0" + toDisplayString(item.name), 1)
            ], 8, _hoisted_9)
          ])),
          createElementVNode("view", _hoisted_10, toDisplayString(item.name), 1)
        ])) : _ctx.listType == "list" ? (openBlock(), createElementBlock("view", _hoisted_11, [
          createElementVNode("view", {
            class: normalizeClass(["nut-uploader__preview-img__file__name", [item.status]]),
            onClick: ($event) => _ctx.fileItemClick(item)
          }, [
            createVNode(_component_nut_icon, { name: "link" }),
            createTextVNode("\xA0" + toDisplayString(item.name), 1)
          ], 10, _hoisted_12),
          createVNode(_component_nut_icon, {
            class: "nut-uploader__preview-img__file__del",
            onClick: ($event) => _ctx.onDelete(item, index),
            color: "#808080",
            name: "del"
          }, null, 8, ["onClick"]),
          item.status == "uploading" ? (openBlock(), createBlock(_component_nut_progress, {
            key: 0,
            size: "small",
            percentage: item.percentage,
            "stroke-color": "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
            "show-text": false
          }, null, 8, ["percentage"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    }), 128)),
    _ctx.listType == "picture" && !_ctx.$slots.default && _ctx.maximum - _ctx.fileList.length ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(["nut-uploader__upload", [_ctx.listType]])
    }, [
      createVNode(_component_nut_icon, {
        size: _ctx.uploadIconSize,
        color: "#808080",
        name: _ctx.uploadIcon
      }, null, 8, ["size", "name"]),
      createVNode(_component_nut_button, {
        class: "nut-uploader__input",
        onClick: _ctx.chooseImage
      }, null, 8, ["onClick"])
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var index_taro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { FileItem, index_taro as default };
