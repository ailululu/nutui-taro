/*!
* @nutui/nutui-taro v3.1.15 Fri Jan 21 2022 15:42:05 GMT+0800 (GMT+08:00)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import { ref, reactive, computed, onMounted, onActivated, onDeactivated, openBlock, createElementBlock, normalizeClass, withModifiers, normalizeStyle, renderSlot } from "vue";
import { c as createComponent } from "./component.js";
import { r as requestAniFrame } from "./raf.js";
import Taro, { eventCenter, getCurrentInstance } from "@tarojs/taro";
import { _ as _export_sfc } from "./plugin-vue_export-helper.js";
const { componentName, create } = createComponent("drag");
const _sfc_main = create({
  props: {
    attract: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: "all"
    },
    boundary: {
      type: Object,
      default: () => {
        return {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
      }
    }
  },
  setup(props, { emit }) {
    const myDrag = ref();
    const state = reactive({
      keepAlive: false,
      elWidth: 0,
      elHeight: 0,
      screenWidth: 0,
      screenHeight: 0,
      startTop: 0,
      startLeft: 0,
      initTop: 0,
      nx: 0,
      ny: 0,
      xPum: 0,
      yPum: 0,
      top: 0,
      left: 0,
      position: { x: 0, y: 0 },
      boundary: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    });
    const classes = computed(() => {
      const prefixCls = "nut-taro-drag";
      return {
        [prefixCls]: true
      };
    });
    const domElem = Taro.getSystemInfoSync();
    function getInfo() {
      const query = Taro.createSelectorQuery();
      query.select(".myDrag").boundingClientRect((rec) => {
        state.elWidth = rec.width;
        state.elHeight = rec.height;
        state.initTop = rec.top;
      }).exec();
      console.log(domElem.windowWidth);
      state.screenWidth = domElem.screenWidth;
      state.screenHeight = domElem.screenHeight;
    }
    function goLeft() {
      if (state.boundary.left) {
        if (+state.left.split("px")[0] > state.boundary.left) {
          state.left = +state.left.split("px")[0] - 10 + "px";
          requestAniFrame(() => {
            goLeft();
          });
        } else {
          state.left = `${state.boundary.left}px`;
        }
      } else {
        if (+state.left.split("px")[0] > 10) {
          state.left = +state.left.split("px")[0] - 10 + "px";
          requestAniFrame(() => {
            goLeft();
          });
        } else {
          state.left = "0px";
        }
      }
    }
    function goRight(rightLocation) {
      if (rightLocation - parseInt(state.left.split("px")[0]) > 10) {
        state.left = parseInt(state.left.split("px")[0]) + 10 + "px";
        requestAniFrame(() => {
          goRight(rightLocation);
        });
      } else {
        state.left = rightLocation + "px";
      }
    }
    function touchMove(e) {
      e.preventDefault();
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        state.nx = touch.clientX - state.position.x;
        state.ny = touch.clientY - state.position.y;
        state.xPum = state.startLeft + state.nx;
        state.yPum = state.startTop + state.ny;
        const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
        if (Math.abs(state.xPum) > rightLocation) {
          state.xPum = rightLocation;
        } else if (state.xPum <= state.boundary.left) {
          state.xPum = state.boundary.left;
        }
        if (state.yPum < state.boundary.top) {
          state.yPum = state.boundary.top;
        } else if (state.yPum > state.screenHeight - state.elHeight - state.boundary.bottom) {
          state.yPum = state.screenHeight - state.elHeight - state.boundary.bottom;
        }
        if (props.direction != "y") {
          state.left = state.xPum;
        }
        if (props.direction != "x") {
          state.top = state.yPum;
        }
      }
    }
    function touchEnd(e) {
      const touch = e.changedTouches[0];
      let currX = touch.clientX;
      const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
      if (currX > rightLocation) {
        currX = rightLocation;
      } else if (currX < state.boundary.left) {
        currX = state.boundary.left;
      } else {
        currX = currX < state.screenWidth / 2 ? state.boundary.left : rightLocation;
      }
      if (props.direction != "y" && props.attract) {
        if (currX < state.screenWidth / 2) {
          requestAniFrame(() => {
            goLeft();
          });
        } else {
          requestAniFrame(() => {
            goRight(rightLocation);
          });
        }
      }
      if (props.direction !== "x") {
        state.top = state.yPum;
      }
    }
    function touchStart(e) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const query = Taro.createSelectorQuery();
      let id = (_a = e == null ? void 0 : e.mpEvent) == null ? void 0 : _a.currentTarget.id;
      let offsetTop = (_b = e == null ? void 0 : e.currentTarget) == null ? void 0 : _b.offsetTop;
      let offsetLeft = (_c = e == null ? void 0 : e.currentTarget) == null ? void 0 : _c.offsetLeft;
      const touches = e.touches[0];
      const mobileTop = (_f = (_e = (_d = e.touches[0]) == null ? void 0 : _d.target) == null ? void 0 : _e.parentNode) == null ? void 0 : _f.style.top;
      const mobileLeft = (_i = (_h = (_g = e.touches[0]) == null ? void 0 : _g.target) == null ? void 0 : _h.parentNode) == null ? void 0 : _i.style.left;
      query.selectAll(".myDrag").boundingClientRect((rec) => {
        rec.forEach((element) => {
          if (id && id == element.id) {
            state.startTop = element.top - offsetTop;
            state.startLeft = element.left - offsetLeft;
          } else if (mobileTop) {
            state.startTop = Number(mobileTop.slice(0, -2));
            state.startLeft = Number(mobileLeft.slice(0, -2));
          }
        });
      }).exec();
      state.position.x = touches.clientX;
      state.position.y = touches.clientY;
    }
    onMounted(() => {
      setTimeout(() => {
        getInfo();
      }, 200);
      eventCenter.once(getCurrentInstance().router.onReady, () => {
      });
      state.boundary = props.boundary;
    });
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      myDrag.removeEventListener("touchstart", touchStart);
      myDrag.removeEventListener("touchmove", touchMove);
      myDrag.removeEventListener("touchend", touchEnd);
    });
    return {
      classes,
      myDrag,
      touchStart,
      touchMove,
      touchEnd,
      state
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass([_ctx.classes, "myDrag"]),
    ref: "myDrag",
    onTouchstart: _cache[0] || (_cache[0] = ($event) => _ctx.touchStart($event)),
    onTouchmove: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.touchMove($event), ["prevent"])),
    catchtouchmove: "true",
    style: normalizeStyle({
      transform: ` translate(${_ctx.state.left + "px"}, ${_ctx.state.top + "px"})`,
      top: _ctx.state.top + "px",
      left: _ctx.state.left + "px"
    })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 38);
}
var index_taro = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { index_taro as default };
